import fs from 'fs';
import { createClient } from '@supabase/supabase-js';

// Carregar vari√°veis de ambiente
const envContent = fs.readFileSync('.env', 'utf8');
const envVars = {};
envContent.split('\n').forEach(line => {
  if (line.trim() && !line.startsWith('#')) {
    const [key, ...valueParts] = line.split('=');
    const value = valueParts.join('=').replace(/["']/g, '').trim();
    envVars[key.trim()] = value;
  }
});

const supabaseUrl = `https://${envVars.VITE_SUPABASE_PROJECT_ID}.supabase.co`;
const supabaseKey = envVars.VITE_SUPABASE_PUBLISHABLE_KEY;

const supabase = createClient(supabaseUrl, supabaseKey);

let testResults = [];
let testPatientId = null;

function logTest(testName, passed, details = '') {
  const status = passed ? '‚úÖ PASSOU' : '‚ùå FALHOU';
  console.log(`${status} - ${testName}`);
  if (details) console.log(`   ${details}`);
  testResults.push({ name: testName, passed, details });
}

async function createTestData() {
  console.log('\nüìä Criando dados de teste para relat√≥rios...');
  
  // Criar paciente de teste
  const { data: patient, error: patientError } = await supabase
    .from('patients')
    .insert({
      full_name: 'Jo√£o Santos - Teste Relat√≥rios',
      birth_date: '1950-05-15',
      bed: 'Leito 205A',
      notes: 'Paciente criado para teste de relat√≥rios',
      is_active: true
    })
    .select()
    .single();

  if (patientError) {
    console.error('‚ùå Erro ao criar paciente:', patientError);
    return false;
  }

  testPatientId = patient.id;
  console.log(`‚úÖ Paciente criado: ${patient.full_name} (ID: ${patient.id})`);

  // Criar eventos de diferentes tipos e hor√°rios
  const now = new Date();
  const events = [
    {
      patient_id: patient.id,
      type: 'med',
      med_name: 'Paracetamol',
      med_dose: '750mg',
      occurred_at: new Date(now.getTime() - 2 * 60 * 60 * 1000).toISOString(), // 2h atr√°s
      notes: 'Administrado para dor de cabe√ßa'
    },
    {
      patient_id: patient.id,
      type: 'drink',
      volume_ml: 250,
      occurred_at: new Date(now.getTime() - 1 * 60 * 60 * 1000).toISOString(), // 1h atr√°s
      notes: '√Ågua'
    },
    {
      patient_id: patient.id,
      type: 'meal',
      meal_desc: 'Jantar - sopa de legumes',
      occurred_at: new Date(now.getTime() - 3 * 60 * 60 * 1000).toISOString(), // 3h atr√°s
      notes: 'Aceitou bem a refei√ß√£o'
    },
    {
      patient_id: patient.id,
      type: 'note',
      notes: 'Paciente relatou melhora na dor - Observa√ß√£o m√©dica',
      occurred_at: new Date(now.getTime() - 30 * 60 * 1000).toISOString() // 30min atr√°s
    },
    {
      patient_id: patient.id,
      type: 'med',
      med_name: 'Omeprazol',
      med_dose: '20mg',
      occurred_at: new Date(now.getTime() - 24 * 60 * 60 * 1000).toISOString(), // 24h atr√°s
      notes: 'Protetor g√°strico'
    }
  ];

  const { error: eventsError } = await supabase
    .from('events')
    .insert(events);

  if (eventsError) {
    console.error('‚ùå Erro ao criar eventos:', eventsError);
    return false;
  }

  console.log(`‚úÖ ${events.length} eventos criados para teste`);
  return true;
}

async function testReportGeneration() {
  console.log('\nüìã Teste 1: Relat√≥rio geral do paciente...');
  
  const { data: allEvents, error } = await supabase
    .from('events')
    .select('*')
    .eq('patient_id', testPatientId)
    .order('occurred_at', { ascending: false });

  if (error) {
    logTest('Relat√≥rio Geral', false, `Erro: ${error.message}`);
    return;
  }

  logTest('Relat√≥rio Geral', allEvents.length > 0, `${allEvents.length} eventos encontrados`);
  
  // Mostrar resumo dos eventos
  console.log('   Eventos encontrados:');
  allEvents.forEach((event, index) => {
    const time = new Date(event.occurred_at).toLocaleString('pt-BR');
    let description = '';
    
    switch(event.type) {
      case 'med':
        description = `${event.med_name} ${event.med_dose}`;
        break;
      case 'drink':
        description = `${event.volume_ml}ml de l√≠quido`;
        break;
      case 'meal':
        description = event.meal_desc;
        break;
      case 'note':
        description = event.notes ? event.notes.substring(0, 50) + '...' : 'Anota√ß√£o';
        break;
    }
    
    console.log(`   ${index + 1}. [${event.type.toUpperCase()}] ${time} - ${description}`);
  });
}

async function testReportsByType() {
  console.log('\nüíä Teste 2: Relat√≥rio por tipo (medicamentos)...');
  
  const { data: medEvents, error } = await supabase
    .from('events')
    .select('*')
    .eq('patient_id', testPatientId)
    .eq('type', 'med')
    .order('occurred_at', { ascending: false });

  if (error) {
    logTest('Relat√≥rio por Tipo', false, `Erro: ${error.message}`);
    return;
  }

  logTest('Relat√≥rio por Tipo', medEvents.length > 0, `${medEvents.length} medicamentos encontrados`);
  
  medEvents.forEach((event, index) => {
    const time = new Date(event.occurred_at).toLocaleString('pt-BR');
    console.log(`   ${index + 1}. ${time} - ${event.med_name} ${event.med_dose}`);
  });
}

async function testReportsByPeriod() {
  console.log('\nüìÖ Teste 3: Relat√≥rio por per√≠odo (√∫ltimas 2 horas)...');
  
  const twoHoursAgo = new Date(Date.now() - 2 * 60 * 60 * 1000).toISOString();
  
  const { data: recentEvents, error } = await supabase
    .from('events')
    .select('*')
    .eq('patient_id', testPatientId)
    .gte('occurred_at', twoHoursAgo)
    .order('occurred_at', { ascending: false });

  if (error) {
    logTest('Relat√≥rio por Per√≠odo', false, `Erro: ${error.message}`);
    return;
  }

  logTest('Relat√≥rio por Per√≠odo', recentEvents.length > 0, `${recentEvents.length} eventos nas √∫ltimas 2h`);
  
  recentEvents.forEach((event, index) => {
    const time = new Date(event.occurred_at).toLocaleString('pt-BR');
    let description = '';
    
    switch(event.type) {
      case 'med':
        description = `${event.med_name} ${event.med_dose}`;
        break;
      case 'drink':
        description = `${event.volume_ml}ml`;
        break;
      case 'note':
        description = event.notes ? event.notes.substring(0, 30) + '...' : 'Anota√ß√£o';
        break;
    }
    
    console.log(`   ${index + 1}. [${event.type.toUpperCase()}] ${time} - ${description}`);
  });
}

async function testReportSummary() {
  console.log('\nüìä Teste 4: Resumo estat√≠stico...');
  
  const { data: events, error } = await supabase
    .from('events')
    .select('type')
    .eq('patient_id', testPatientId);

  if (error) {
    logTest('Resumo Estat√≠stico', false, `Erro: ${error.message}`);
    return;
  }

  // Contar eventos por tipo
  const summary = events.reduce((acc, event) => {
    acc[event.type] = (acc[event.type] || 0) + 1;
    return acc;
  }, {});

  logTest('Resumo Estat√≠stico', Object.keys(summary).length > 0, 'Estat√≠sticas geradas');
  
  console.log('   Resumo por tipo:');
  Object.entries(summary).forEach(([type, count]) => {
    const typeNames = {
      med: 'Medicamentos',
      drink: 'L√≠quidos',
      meal: 'Refei√ß√µes',
      note: 'Anota√ß√µes'
    };
    console.log(`   - ${typeNames[type] || type}: ${count}`);
  });
}

async function testReportExport() {
  console.log('\nüìÑ Teste 5: Simula√ß√£o de exporta√ß√£o de relat√≥rio...');
  
  const { data: events, error } = await supabase
    .from('events')
    .select(`
      *,
      patients!inner(full_name, bed)
    `)
    .eq('patient_id', testPatientId)
    .order('occurred_at', { ascending: false });

  if (error) {
    logTest('Exporta√ß√£o de Relat√≥rio', false, `Erro: ${error.message}`);
    return;
  }

  // Simular gera√ß√£o de relat√≥rio em formato texto
  const reportContent = generateTextReport(events);
  
  logTest('Exporta√ß√£o de Relat√≥rio', reportContent.length > 0, `Relat√≥rio gerado (${reportContent.length} caracteres)`);
  
  console.log('   Preview do relat√≥rio:');
  console.log('   ' + reportContent.substring(0, 200) + '...');
}

function generateTextReport(events) {
  if (!events || events.length === 0) return '';
  
  const patient = events[0].patients;
  let report = `RELAT√ìRIO DE CUIDADOS\n`;
  report += `===================\n\n`;
  report += `Paciente: ${patient.full_name}\n`;
  report += `Leito: ${patient.bed}\n`;
  report += `Data do relat√≥rio: ${new Date().toLocaleString('pt-BR')}\n\n`;
  
  report += `EVENTOS REGISTRADOS:\n`;
  report += `-------------------\n`;
  
  events.forEach((event, index) => {
    const time = new Date(event.occurred_at).toLocaleString('pt-BR');
    report += `${index + 1}. ${time} - ${event.type.toUpperCase()}\n`;
    
    switch(event.type) {
      case 'med':
        report += `   Medicamento: ${event.med_name} ${event.med_dose}\n`;
        break;
      case 'drink':
        report += `   Volume: ${event.volume_ml}ml\n`;
        break;
      case 'meal':
        report += `   Refei√ß√£o: ${event.meal_desc}\n`;
        break;
      case 'note':
        report += `   Anota√ß√£o: ${event.notes}\n`;
        break;
    }
    
    if (event.notes) {
      report += `   Observa√ß√µes: ${event.notes}\n`;
    }
    report += `\n`;
  });
  
  return report;
}

async function cleanup() {
  console.log('\nüßπ Limpeza dos dados de teste...');
  
  if (testPatientId) {
    // Remover eventos
    const { error: eventsError } = await supabase
      .from('events')
      .delete()
      .eq('patient_id', testPatientId);

    if (eventsError) {
      console.error('‚ùå Erro ao remover eventos:', eventsError);
    } else {
      console.log('‚úÖ Eventos removidos');
    }

    // Remover paciente
    const { error: patientError } = await supabase
      .from('patients')
      .delete()
      .eq('id', testPatientId);

    if (patientError) {
      console.error('‚ùå Erro ao remover paciente:', patientError);
    } else {
      console.log('‚úÖ Paciente de teste removido');
    }
  }
}

async function runReportsTests() {
  console.log('üè• INICIANDO TESTES DE RELAT√ìRIOS');
  console.log('==================================\n');

  try {
    // Criar dados de teste
    const dataCreated = await createTestData();
    if (!dataCreated) {
      console.log('‚ùå Falha na cria√ß√£o de dados de teste');
      return;
    }

    // Executar testes
    await testReportGeneration();
    await testReportsByType();
    await testReportsByPeriod();
    await testReportSummary();
    await testReportExport();

  } catch (error) {
    console.error('‚ùå Erro durante os testes:', error);
  } finally {
    await cleanup();
  }

  // Relat√≥rio final
  console.log('\n==================================================');
  console.log('üìã RELAT√ìRIO FINAL - GERA√á√ÉO DE RELAT√ìRIOS');
  console.log('==================================================');
  
  testResults.forEach(result => {
    const status = result.passed ? '‚úÖ PASSOU' : '‚ùå FALHOU';
    console.log(`${status} - ${result.name}`);
  });

  const passedTests = testResults.filter(r => r.passed).length;
  const totalTests = testResults.length;
  const successRate = ((passedTests / totalTests) * 100).toFixed(1);

  console.log('\nüìä RESUMO:');
  console.log(`   Testes executados: ${totalTests}`);
  console.log(`   Testes aprovados: ${passedTests}`);
  console.log(`   Taxa de sucesso: ${successRate}%`);

  if (passedTests === totalTests) {
    console.log('\nüéâ TODOS OS TESTES DE RELAT√ìRIOS PASSARAM!');
    console.log('üìä Sistema de relat√≥rios funcionando perfeitamente.');
  } else {
    console.log('\n‚ö†Ô∏è  ALGUNS TESTES FALHARAM!');
    console.log('üîß Verifique os erros acima para corre√ß√µes necess√°rias.');
  }
}

// Executar testes
runReportsTests().catch(console.error);